/*
*
*  Copyright 2011, 2012 by the CALATK development team
*
*   Licensed under the Apache License, Version 2.0 (the "License");
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.
*
*
*/

#include "CApplication.h"

namespace CALATK
{

void CApplication::InstantiateConfigs()
{
  this->m_CombinedAlgorithmJSONConfig = new CJSONConfiguration;
  this->m_CombinedDataJSONConfig = new CJSONConfiguration;
  this->m_CleanedAlgorithmJSONConfig = new CJSONConfiguration;
  this->m_CleanedDataJSONConfig = new CJSONConfiguration;
}

CApplication::CApplication():
  m_CombinedDataJSONConfigurationAutogeneratedFromSourceAndTargetImageFiles( false )
{
  this->InstantiateConfigs();
}


CApplication::CApplication( const int argc, char **argv ):
  m_CombinedDataJSONConfigurationAutogeneratedFromSourceAndTargetImageFiles( false )
{
  this->InstantiateConfigs();

  if( argc < 3 )
    {
    std::string usage = "Usage: CALATKCommandLine "
          "<algorithm_parameters_config.json> "
          "(<data_parameters_config.json> | <source_image_file> <target_image_file>) "
          "[<used_algorithm_parameters_config.json>] "
          "[<used_data_parameters_config.json>]\n";
    throw std::runtime_error( usage.c_str() );
    }

  this->SetGivenAlgorithmConfigurationFile( argv[1] );
  const std::string argv2( argv[2] );
  if( argv2.length() > 5 && std::string( ".json" ).compare( argv2.substr( argv2.length() - 5 )))
    {
    if( argc < 4 )
      {
      throw std::runtime_error( "Insufficient number of arguments, must supply both source and target image." );
      }
    this->SetGivenSourceAndTargetImageFiles( argv[2], argv[3] );

    if( argc > 4 )
      {
      this->SetUsedAlgorithmConfigurationFile( argv[4] );
      }

    if( argc > 5 )
      {
      this->SetUsedDataConfigurationFile( argv[5] );
      }
    }
  else
    {
    this->SetGivenDataConfigurationFile( argv2 );

    if( argc > 3 )
      {
      this->SetUsedAlgorithmConfigurationFile( argv[3] );
      }

    if( argc > 4 )
      {
      this->SetUsedDataConfigurationFile( argv[4] );
      }
    }
}


void CApplication::SetGivenAlgorithmConfigurationFile( const std::string & file )
{
  this->m_GivenAlgorithmConfigurationFile = file;
  this->m_CombinedAlgorithmJSONConfig->ReadJSONFile( file );
}


std::string CApplication::GetGivenAlgorithmConfigurationFile() const
{
  return this->m_GivenAlgorithmConfigurationFile;
}


void CApplication::SetGivenSourceAndTargetImageFiles( const std::string & source, const std::string & target )
{
  // The source image goes into Timepoint 0.0.
  Json::Value sourceTimepoint( 0.0 );
  Json::Value sourceFile( source );
  Json::Value sourceTimeFile;
  sourceTimeFile[0] = sourceTimepoint;
  sourceTimeFile[1] = sourceFile;

  // The target image goes into Timepoint 1.0.
  Json::Value targetTimepoint( 1.0 );
  Json::Value targetFile( target );
  Json::Value targetTimeFile;
  targetTimeFile[0] = targetTimepoint;
  targetTimeFile[1] = targetFile;

  Json::Value timePoints;
  timePoints[0] = sourceTimeFile;
  timePoints[1] = targetTimeFile;

  Json::Value subjects;
  subjects["subject1"] = timePoints;

  this->m_CombinedDataJSONConfig->InitializeEmptyRoot();
  Json::Value & root = *(m_CombinedDataJSONConfig->GetRootPointer());

  root["Inputs"] = subjects;
  this->m_CombinedDataJSONConfigurationAutogeneratedFromSourceAndTargetImageFiles = true;
}


void CApplication::SetGivenDataConfigurationFile( const std::string & file )
{
  this->m_GivenDataConfigurationFile = file;
  this->m_CombinedDataJSONConfig->ReadJSONFile( file );
}


std::string CApplication::GetGivenDataConfigurationFile() const
{
  return this->m_GivenDataConfigurationFile;
}


void CApplication::SetUsedAlgorithmConfigurationFile( const std::string & file )
{
  this->m_UsedAlgorithmConfigurationFile = file;
}


std::string CApplication::GetUsedAlgorithmConfigurationFile() const
{
  return this->m_UsedAlgorithmConfigurationFile;
}


void CApplication::SetUsedDataConfigurationFile( const std::string & file )
{
  this->m_UsedDataConfigurationFile = file;
}


std::string CApplication::GetUsedDataConfigurationFile() const
{
  return this->m_UsedDataConfigurationFile;
}


void CApplication::Solve()
{
  // Check to make sure we have an algorithm and data input.
  Json::Value & combinedAlgorithmConfigRoot = *(this->m_CombinedAlgorithmJSONConfig->GetRootPointer());
  Json::Value & combinedDataConfigRoot = *(this->m_CombinedDataJSONConfig->GetRootPointer());
  if( &combinedAlgorithmConfigRoot == NULL )
    {
    throw std::logic_error( "Algorithm configuration was not set for CApplication" );
    }
  if( &combinedDataConfigRoot == NULL )
    {
    throw std::logic_error( "Data configuration was not set for CApplication" );
    }

  // Initialize the used JSON configurations.
  this->m_CleanedAlgorithmJSONConfig->InitializeEmptyRoot();
  this->m_CleanedDataJSONConfig->InitializeEmptyRoot();
  Json::Value & cleanedAlgorithmConfigRoot = *(this->m_CleanedAlgorithmJSONConfig->GetRootPointer());

  // Get the float type (double or float).
  // The default float type.
  static const std::string defaultFloatType = "double";
  std::string floatType = defaultFloatType;
  const Json::Value & givenAlgorithmConfig = combinedAlgorithmConfigRoot["Algorithm"];
  if( givenAlgorithmConfig != Json::nullValue && givenAlgorithmConfig["FloatType"] != Json::nullValue )
    {
    floatType = givenAlgorithmConfig["FloatType"].asString();
    cleanedAlgorithmConfigRoot["Algorithm"]["FloatType"] = floatType;
    }
  else
    {
    combinedAlgorithmConfigRoot["Algorithm"]["FloatType"] = defaultFloatType;
    cleanedAlgorithmConfigRoot["Algorithm"]["FloatType"] = defaultFloatType;
    }

  // Get the image dimension.
  unsigned int imageDimension = 3;
  if( givenAlgorithmConfig != Json::nullValue && givenAlgorithmConfig["ImageDimension"] != Json::nullValue )
    {
    imageDimension = givenAlgorithmConfig["ImageDimension"].asInt();
    cleanedAlgorithmConfigRoot["Algorithm"]["ImageDimension"] = imageDimension;
    }
  else
    {
    const Json::Value inputs = combinedDataConfigRoot["Inputs"];
    if( inputs != Json::nullValue )
      {
      // use the dimension from the first image of the first subject
      const Json::Value firstSubject = *(inputs.begin());
      if( firstSubject != Json::nullValue )
        {
        // first time point, the image file name is the second entry
        Json::Value firstImage = firstSubject[0][1];
        if( firstImage != Json::nullValue )
          {
          imageDimension = GetNonSingletonImageDimensionFromFile( firstImage.asString() );
          }
        }
      }
    combinedAlgorithmConfigRoot["Algorithm"]["ImageDimension"] = imageDimension;
    cleanedAlgorithmConfigRoot["Algorithm"]["ImageDimension"] = imageDimension;
    }

  if( floatType.compare( "float" ) == 0 )
    {
    switch( imageDimension )
      {
    case 1:
      this->InternalSolve< float, 1 >();
      break;
    case 2:
      this->InternalSolve< float, 2 >();
      break;
    case 3:
      this->InternalSolve< float, 3 >();
      break;
    default:
      std::ostringstream message;
      message << "Unsupported image dimension: " << imageDimension;
      throw std::runtime_error( message.str().c_str() );
      }
    }
  else if( floatType.compare( "double" ) == 0 )
    {
    switch( imageDimension )
      {
    case 1:
      this->InternalSolve< double, 1 >();
      break;
    case 2:
      this->InternalSolve< double, 2 >();
      break;
    case 3:
      this->InternalSolve< double, 3 >();
      break;
    default:
      std::ostringstream message;
      message << "Unsupported image dimension: " << imageDimension;
      throw std::runtime_error( message.str().c_str() );
      }
    }
  else
    {
    const std::string message = "Invalid Algorithm FloatType: " + floatType;
    throw std::runtime_error( message.c_str() );
    }

  if( this->m_UsedAlgorithmConfigurationFile.length() > 0 )
    {
    this->m_CleanedAlgorithmJSONConfig->WriteCurrentConfigurationToJSONFile( this->m_UsedAlgorithmConfigurationFile );
    }

  if( this->m_UsedDataConfigurationFile.length() > 0 )
    {
    // TODO: replace with used configuration.
    this->m_CombinedDataJSONConfig->WriteCurrentConfigurationToJSONFile( this->m_UsedDataConfigurationFile );
    }

}


template< class TFloat, unsigned int VImageDimension >
void
CApplication::InternalSolve()
{
  // The default algorithm
  static const std::string defaultAlgorithmName = "LDDMMGrowthModelRegistration";
  std::string algorithmName = defaultAlgorithmName;
  Json::Value & combinedAlgorithmConfigRoot = *(this->m_CombinedAlgorithmJSONConfig->GetRootPointer());
  Json::Value & cleanedAlgorithmConfigRoot = *(this->m_CleanedAlgorithmJSONConfig->GetRootPointer());
  Json::Value & combinedAlgorithmConfig = combinedAlgorithmConfigRoot["Algorithm"];
  if( combinedAlgorithmConfig != Json::nullValue )
    {
    const Json::Value calatkAlgorithmName = combinedAlgorithmConfig["Name"];
    if( calatkAlgorithmName != Json::nullValue )
      {
      algorithmName = calatkAlgorithmName.asString();
      cleanedAlgorithmConfigRoot["Algorithm"]["Name"] = algorithmName;
      }
    }
  else
    {
    combinedAlgorithmConfigRoot["Algorithm"]["Name"] = algorithmName;
    cleanedAlgorithmConfigRoot["Algorithm"]["Name"] = algorithmName;
    }

  // Create the algorithm.
  typedef CAlgorithmFactory< TFloat, VImageDimension > AlgorithmFactoryType;
  typename AlgorithmFactoryType::Pointer algorithmFactory = new AlgorithmFactoryType;
  typedef typename AlgorithmFactoryType::AlgorithmBaseType AlgorithmBaseType;
  typename AlgorithmBaseType::Pointer algorithmBase = algorithmFactory->CreateNewAlgorithm( algorithmName );

  // Create the image manager.
  typedef CImageManager< TFloat, VImageDimension > ImageManagerType;
  typename ImageManagerType::Pointer imageManager;
  if( combinedAlgorithmConfigRoot["MultiScaleSettings"] != Json::nullValue )
    {
    typedef CImageManager< TFloat, VImageDimension > ImageManagerMultiScaleType;
    imageManager = new ImageManagerMultiScaleType;
    }
  else
    {
    typedef CImageManager< TFloat, VImageDimension > ImageManagerFullScaleType;
    imageManager = new ImageManagerFullScaleType;
    }
  algorithmBase->SetImageManagerPointer( imageManager );

  imageManager->SetAlgorithmAutoConfiguration( this->m_CombinedAlgorithmJSONConfig, this->m_CleanedAlgorithmJSONConfig );
  imageManager->SetDataAutoConfiguration( this->m_CombinedDataJSONConfig, this->m_CleanedDataJSONConfig );
  imageManager->ReadInputsFromDataJSONConfiguration();

  // Do it!
  algorithmBase->SetAutoConfiguration( this->m_CombinedAlgorithmJSONConfig, this->m_CleanedAlgorithmJSONConfig );
  algorithmBase->Solve();

  imageManager->WriteOutputsFromDataJSONConfiguration( algorithmBase );
}

} // end namespace CALATK
